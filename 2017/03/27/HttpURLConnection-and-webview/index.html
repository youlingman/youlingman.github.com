<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>HttpURLConnection和webview的协同使用 | cyl&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="webview中使用post加载在项目中遇到一个需求，需要在android的webview中对特定请求（其实就是第一次打开webview的时候）进行可自定义header的post请求，而原生webview提供的post API是这样的： public void postUrl(String url, byte[] postData); 不可以自定义header，反观get API可以自定义head">
<meta name="keywords" content="android">
<meta property="og:type" content="article">
<meta property="og:title" content="HttpURLConnection和webview的协同使用">
<meta property="og:url" content="http://icyl.rocks/2017/03/27/HttpURLConnection-and-webview/index.html">
<meta property="og:site_name" content="cyl&#39;s blog">
<meta property="og:description" content="webview中使用post加载在项目中遇到一个需求，需要在android的webview中对特定请求（其实就是第一次打开webview的时候）进行可自定义header的post请求，而原生webview提供的post API是这样的： public void postUrl(String url, byte[] postData); 不可以自定义header，反观get API可以自定义head">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-04-30T10:26:10.993Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HttpURLConnection和webview的协同使用">
<meta name="twitter:description" content="webview中使用post加载在项目中遇到一个需求，需要在android的webview中对特定请求（其实就是第一次打开webview的时候）进行可自定义header的post请求，而原生webview提供的post API是这样的： public void postUrl(String url, byte[] postData); 不可以自定义header，反观get API可以自定义head">
  
    <link rel="alternative" href="/atom.xml" title="cyl&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
</head></html>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main"><article id="post-HttpURLConnection-and-webview" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HttpURLConnection和webview的协同使用
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/03/27/HttpURLConnection-and-webview/" class="article-date">
  <time datetime="2017-03-27T06:34:40.000Z" itemprop="datePublished">2017-03-27</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="webview中使用post加载"><a href="#webview中使用post加载" class="headerlink" title="webview中使用post加载"></a>webview中使用post加载</h3><p>在项目中遇到一个需求，需要在android的webview中对特定请求（其实就是第一次打开webview的时候）进行可自定义header的post请求，而原生webview提供的post API是这样的：</p>
<pre><code>public void postUrl(String url, byte[] postData);
</code></pre><p>不可以自定义header，反观get API可以自定义header，真让人头大。</p>
<pre><code>void loadUrl (String url, 
            Map&lt;String, String&gt; additionalHttpHeaders)
</code></pre><a id="more"></a>
<p>网上找了一轮，有以下几种实现思路：</p>
<ul>
<li>自定义WebViewClient，里面可以统一拦截请求并实现对应处理逻辑，这里的问题是需要额外规则来适配特定的请求；</li>
<li>重写webview，为了这个小需求重写webview不太现实；</li>
<li>手写http post请求，然后使用webview的loadData方法加载返回内容；</li>
</ul>
<p>由于开发框架封了一个公共的webview，对webview或者webviewclient的改动可能会影响到其它业务组件，最后决定对第一次请求，使用HttpURLConnection手动post请求，然后打开webview并把返回的内容（HTML文本）load进去，对原有逻辑影响最小。</p>
<p>webview可以认为是基于webkit的浏览器客户端，里面封装好了对请求的相关处理，单独实现请求还需要注意相关的特殊处理，下面是踩过的两个坑。</p>
<h3 id="HttpURLConnection和webview协同-重定向处理"><a href="#HttpURLConnection和webview协同-重定向处理" class="headerlink" title="HttpURLConnection和webview协同-重定向处理"></a>HttpURLConnection和webview协同-重定向处理</h3><p>HttpURLConnection有一个方法setInstanceFollowRedirects可以设置是否自动follow重定向。</p>
<pre><code>public void setInstanceFollowRedirects(boolean followRedirects)
</code></pre><p>但是如果原URL是http而目标URL是https的话这个方法是不能自动跳转的，搜了下<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4620571" target="_blank" rel="noopener">这里</a>提到java由于安全原因不允许不同协议间的自动重定向跳转，需要应用层面去实现各自的重定向逻辑。</p>
<p>实现逻辑很简单，就是判一下返回码，如果为重定向的返回码，则把header里Location域的url取出来load进webview里。</p>
<h3 id="HttpURLConnection和webview协同-cookie处理"><a href="#HttpURLConnection和webview协同-cookie处理" class="headerlink" title="HttpURLConnection和webview协同-cookie处理"></a>HttpURLConnection和webview协同-cookie处理</h3><p>根据官方文档，android应用的webview实例的cookie都是由<a href="https://developer.android.com/reference/android/webkit/CookieManager.html" target="_blank" rel="noopener">CookieManager</a>来管理的，因此HttpURLConnection请求返回的cookie需要同步到CookieManager里，然后这个CookieManager里面坑不少，主要有以下几个：</p>
<ul>
<li>如果http response里返了多条cookie，需要调用多次setCookie方法来完成设置；</li>
<li>setCookie方法设置的cookie要带上path信息，否则webview里的ajax请求不能同步到对应cookie（这个setCookie方法为啥不提供一个接受HttpCookie类型参数的签名呢，只接受String类型的参数用起来太不方便了）；</li>
<li>在低于21的SDK版本里，CookieManager的removeSessionCookie方法和CookieSyncManager的sync方法是<strong>非阻塞异步操作</strong>，而且具体逻辑封起来了，没办法进行有效的线程同步，这意味着啥呢，就是说可能cookie设置完了然后removeSessionCookie方法才被调用，然后刚设置好的cookie就被清掉了，或者前一个请求的cookie还没设置完呢后续页面已经打开了，然后前一个请求的cookie就没办法同步到后续页面里。解决方案十分暴力，就是当系统SDK版本低于21时，在removeSessionCookie方法和sync方法后面sleep上300到500ms，亲测有效。</li>
</ul>

      

      
        
    </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/07/01/stream-in-scala/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          scala中的Stream
        
      </div>
    </a>
  
  
    <a href="/2017/02/15/lazy-evalutaion-in-scala/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">scala中的延迟求值</div>
    </a>
  
</nav>

  
</article>




<section id="comments">
    <div id="gitalk-container"></div>
    <script type="text/javascript">
        var gitalk = new Gitalk({
              clientID: '4178d7f0ed6bb025e545',
              clientSecret: 'dbb0e0a9532453611c0fa1e8f0942059c6478b67',
              repo: 'youlingman.github.com',
              owner: 'youlingman',
              admin: 'youlingman',
              id: location.pathname,      // Ensure uniqueness and length less than 50{{ page.title }}
              distractionFreeMode: 'true'  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/youlingman" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>
      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2020 youlingman 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/Alex-fun/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/youlingman" class="mobile-nav-link">Github</a>
  
</nav>
    

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>