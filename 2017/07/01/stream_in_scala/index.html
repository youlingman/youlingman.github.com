<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>scala中的Stream | cyl&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在之前scala中的延迟求值中提到，在使用递归遍历的方法解骑士巡游问题时，可以利用延迟求值的方法来获取需要的部分解（而不用依赖if-else等条件控制流），scala提供了一个lazy list来支持按需计算，称为Stream，这里整理一下相关用法和原理。">
<meta name="keywords" content="scala,functional">
<meta property="og:type" content="article">
<meta property="og:title" content="scala中的Stream">
<meta property="og:url" content="http://icyl.rocks/2017/07/01/stream_in_scala/index.html">
<meta property="og:site_name" content="cyl&#39;s blog">
<meta property="og:description" content="在之前scala中的延迟求值中提到，在使用递归遍历的方法解骑士巡游问题时，可以利用延迟求值的方法来获取需要的部分解（而不用依赖if-else等条件控制流），scala提供了一个lazy list来支持按需计算，称为Stream，这里整理一下相关用法和原理。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-03-01T10:48:39.275Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="scala中的Stream">
<meta name="twitter:description" content="在之前scala中的延迟求值中提到，在使用递归遍历的方法解骑士巡游问题时，可以利用延迟求值的方法来获取需要的部分解（而不用依赖if-else等条件控制流），scala提供了一个lazy list来支持按需计算，称为Stream，这里整理一下相关用法和原理。">
  
    <link rel="alternative" href="/atom.xml" title="cyl&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-91857907-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head></html>
<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main"><article id="post-stream_in_scala" class="article article-type-post" itemscope itemprop="blogPost">
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      scala中的Stream
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2017/07/01/stream_in_scala/" class="article-date">
  <time datetime="2017-07-01T11:57:30.000Z" itemprop="datePublished">2017-07-01</time>
</a>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在之前<a href="/2017/02/15/lazy_evalutaion_in_scala/">scala中的延迟求值</a>中提到，在使用递归遍历的方法解<a href="https://en.wikipedia.org/wiki/Knight%27s_tour" target="_blank" rel="noopener">骑士巡游问题</a>时，可以利用延迟求值的方法来获取需要的部分解（而不用依赖if-else等条件控制流），scala提供了一个lazy list来支持按需计算，称为Stream，这里整理一下相关用法和原理。<br><a id="more"></a></p>
<h3 id="问题简化"><a href="#问题简化" class="headerlink" title="问题简化"></a>问题简化</h3><p>对骑士巡游问题作一下抽象，可以将问题描述为“对一个列表（解题空间，骑士所有可能的走法）进行筛选（是否填满棋盘/出发点和结束点是否一致）”，这里将问题简化成同构的问题“对一个列表（整数列表）进行筛选（是否素数）”。</p>
<p>首先先实现一个判断素数函数，并随机生成一个长度为50的整数列表。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">isPrime</span></span>(n : <span class="type">Int</span>): <span class="type">Boolean</span> = n == <span class="number">2</span> || <span class="type">List</span>.range(<span class="number">2</span>, n / <span class="number">2</span> + <span class="number">1</span>).forall(i =&gt; n % i != <span class="number">0</span>)</span><br><span class="line">isPrime: (n: <span class="type">Int</span>)<span class="type">Boolean</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">Seq</span>.fill(<span class="number">50</span>)(<span class="type">Random</span>.nextInt(<span class="number">1000</span>))</span><br><span class="line">list: <span class="type">Seq</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">403</span>, <span class="number">615</span>, <span class="number">930</span>, <span class="number">197</span>, <span class="number">599</span>, <span class="number">841</span>, <span class="number">439</span>, <span class="number">153</span>, <span class="number">655</span>, <span class="number">809</span>, <span class="number">861</span>, <span class="number">942</span>, <span class="number">858</span>, <span class="number">381</span>, <span class="number">299</span>, <span class="number">550</span>, <span class="number">32</span>, <span class="number">343</span>, <span class="number">542</span>, <span class="number">146</span>, <span class="number">872</span>, <span class="number">522</span>, <span class="number">23</span>, <span class="number">569</span>, <span class="number">959</span>, <span class="number">165</span>, <span class="number">631</span>, <span class="number">438</span>, <span class="number">444</span>, <span class="number">589</span>, <span class="number">634</span>, <span class="number">997</span>, <span class="number">145</span>, <span class="number">675</span>, <span class="number">873</span>, <span class="number">155</span>, <span class="number">51</span>, <span class="number">326</span>, <span class="number">610</span>, <span class="number">623</span>, <span class="number">938</span>, <span class="number">343</span>, <span class="number">442</span>, <span class="number">728</span>, <span class="number">364</span>, <span class="number">0</span>, <span class="number">866</span>, <span class="number">188</span>, <span class="number">892</span>, <span class="number">495</span>)</span><br></pre></td></tr></table></figure>
<p>然后对列表作filter。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; list.filter(isPrime).take(<span class="number">5</span>)</span><br><span class="line">res6: <span class="type">Seq</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">197</span>, <span class="number">599</span>, <span class="number">439</span>, <span class="number">809</span>, <span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; list.filter(isPrime)</span><br><span class="line">res5: <span class="type">Seq</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">197</span>, <span class="number">599</span>, <span class="number">439</span>, <span class="number">809</span>, <span class="number">23</span>, <span class="number">569</span>, <span class="number">631</span>, <span class="number">997</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>可见列表中一共有9个素数，如果只需要获取前5个素数，则后面4个素数的筛选都是不必要的。而使用Stream可以免去后续的多余计算，实现按需计算的效果。</p>
<h3 id="按需计算"><a href="#按需计算" class="headerlink" title="按需计算"></a>按需计算</h3><p>要使用Stream，首先可以将List转成Stream，Stream和List用的同一套列表操作API，后续操作也和List版本一致。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> stream = list.toStream</span><br><span class="line">stream: scala.collection.immutable.<span class="type">Stream</span>[<span class="type">Int</span>] = <span class="type">Stream</span>(<span class="number">403</span>, ?)</span><br><span class="line"></span><br><span class="line">scala&gt; stream.filter(isPrime)</span><br><span class="line">res7: scala.collection.immutable.<span class="type">Stream</span>[<span class="type">Int</span>] = <span class="type">Stream</span>(<span class="number">197</span>, ?)</span><br><span class="line"></span><br><span class="line">scala&gt; stream.filter(isPrime).take(<span class="number">5</span>)</span><br><span class="line">res8: scala.collection.immutable.<span class="type">Stream</span>[<span class="type">Int</span>] = <span class="type">Stream</span>(<span class="number">197</span>, ?)</span><br></pre></td></tr></table></figure>
<p>可以看到，List转成Stream后得到的是一个Stream对象 Stream(403, ?)，而执行完筛选素数并取前5个数后的到的仍然是Stream对象 Stream(197, ?)，从中仅能得到第一个素数，后面的仍然是问号。这时候回头看看stream：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; stream</span><br><span class="line">res9: scala.collection.immutable.<span class="type">Stream</span>[<span class="type">Int</span>] = <span class="type">Stream</span>(<span class="number">403</span>, <span class="number">615</span>, <span class="number">930</span>, <span class="number">197</span>, ?)</span><br></pre></td></tr></table></figure>
<p>stream也是仅仅看到原始列表到第一个素数为止的内容，其后同样是问号。下面我们将前5个素数打印出来再回头看看差异。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; stream.filter(isPrime).take(<span class="number">5</span>).foreach(println)</span><br><span class="line"><span class="number">197</span></span><br><span class="line"><span class="number">599</span></span><br><span class="line"><span class="number">439</span></span><br><span class="line"><span class="number">809</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"></span><br><span class="line">scala&gt; stream</span><br><span class="line">res11: scala.collection.immutable.<span class="type">Stream</span>[<span class="type">Int</span>] = <span class="type">Stream</span>(<span class="number">403</span>, <span class="number">615</span>, <span class="number">930</span>, <span class="number">197</span>, <span class="number">599</span>, <span class="number">841</span>, <span class="number">439</span>, <span class="number">153</span>, <span class="number">655</span>, <span class="number">809</span>, <span class="number">861</span>, <span class="number">942</span>, <span class="number">858</span>, <span class="number">381</span>, <span class="number">299</span>, <span class="number">550</span>, <span class="number">32</span>, <span class="number">343</span>, <span class="number">542</span>, <span class="number">146</span>, <span class="number">872</span>, <span class="number">522</span>, <span class="number">23</span>, ?)</span><br></pre></td></tr></table></figure>
<p>当把前5个素数打印出来后，stream中的数据也恰恰仅到第5个素数为止。这里就能看出按需计算的效果，Stream仅对获取到的内容（前5个素数）进行了计算，而没有计算到的部分仍然是问号。接下来进去源码看一下实现原理。</p>
<h3 id="看看源码"><a href="#看看源码" class="headerlink" title="看看源码"></a>看看源码</h3><p>首先从List的toStream方法开始，看看Stream对象的创建。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toStream</span> </span>: <span class="type">Stream</span>[<span class="type">A</span>] =</span><br><span class="line">  <span class="keyword">if</span> (isEmpty) <span class="type">Stream</span>.<span class="type">Empty</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">new</span> <span class="type">Stream</span>.<span class="type">Cons</span>(head, tail.toStream)</span><br></pre></td></tr></table></figure>
<p>先不关心Empty，看看Stream helper中的Cons方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A lazy cons cell, from which streams are built. */</span></span><br><span class="line"><span class="meta">@SerialVersionUID</span>(<span class="number">-602202424901551803</span>L)</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">hd: <span class="type">A</span>, tl: =&gt; <span class="type">Stream</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">Stream</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="literal">false</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">head</span> </span>= hd</span><br><span class="line">  <span class="meta">@volatile</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> tlVal: <span class="type">Stream</span>[<span class="type">A</span>] = _</span><br><span class="line">  <span class="meta">@volatile</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> tlGen = tl _</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tailDefined</span></span>: <span class="type">Boolean</span> = tlGen eq <span class="literal">null</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">Stream</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tailDefined)</span><br><span class="line">      synchronized &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tailDefined) &#123;</span><br><span class="line">          tlVal = tlGen()</span><br><span class="line">          tlGen = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    tlVal</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Cons类继承了Stream，然后有两个参数hd和tl，hd为call-by-value，对应列表的head，tl为call-by-name，对应列表的tail部分，可以看出，hd的值在对象创建时就会进行计算，而tl的值，只有在被访问到时才会进行计算，但是tl的值在哪里会被访问到呢？自然是在tail方法里面。</p>
<p>由于call-by-name的参数存在<strong>每次访问都会重复计算</strong>的问题，这里引入了tlVal、tlGen变量，var tlGen = tl _ 的写法其实是将call-by-name参数tl转成对应的匿名无参函数并赋值给tlGen，以使得变量tlGen也具有call-by-name的特性，这种方法貌似被称为<a href="https://en.wikipedia.org/wiki/Thunk#Functional_programming" target="_blank" rel="noopener">Thunk</a>。控制重复计算的关键是tailDefined的返回值，假定tl不为null，则初始tailDefined为false，而tail方法被访问过后，会计算tl的值并赋给tlVal，然后将tlGen置为null，其后tailDefined将变成true。tail方法中还使用了synchronized和double-check来保证线程同步。</p>
<p>换言之，<strong>tl的值只有在tail方法被调用过才会进行执行/计算，这就是Stream支持按需计算的由来</strong>。而tailDefined表示当前Stream的tail是否已经被访问/计算过，看看Stream.addString方法中的对应逻辑就能知道之前Stream中的问号从何而来。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">addString</span></span>(b: <span class="type">StringBuilder</span>, start: <span class="type">String</span>, sep: <span class="type">String</span>, end: <span class="type">String</span>): <span class="type">StringBuilder</span> = &#123;</span><br><span class="line">	...</span><br><span class="line">      <span class="keyword">if</span> (!cursor.isEmpty) &#123;</span><br><span class="line">        <span class="comment">// Either undefined or cyclic; we can check with tailDefined</span></span><br><span class="line">        <span class="keyword">if</span> (!cursor.tailDefined) b append sep append <span class="string">"?"</span></span><br><span class="line">        <span class="keyword">else</span> b append sep append <span class="string">"..."</span></span><br><span class="line">      &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看看filter和take的实现，就大概清楚Stream实现延迟计算的思路了。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** An alternative way of building and matching Streams using Stream.cons(hd, tl).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">cons</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** A stream consisting of a given first element and remaining elements</span></span><br><span class="line"><span class="comment">   *  @param hd   The first element of the result stream</span></span><br><span class="line"><span class="comment">   *  @param tl   The remaining elements of the result stream</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">A</span>](hd: <span class="type">A</span>, tl: =&gt; <span class="type">Stream</span>[<span class="type">A</span>]) = <span class="keyword">new</span> <span class="type">Cons</span>(hd, tl)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Maps a stream to its head and tail */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>[<span class="type">A</span>](xs: <span class="type">Stream</span>[<span class="type">A</span>]): <span class="type">Option</span>[(<span class="type">A</span>, <span class="type">Stream</span>[<span class="type">A</span>])] = #::.unapply(xs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(n: <span class="type">Int</span>): <span class="type">Stream</span>[<span class="type">A</span>] = (</span><br><span class="line">  <span class="comment">// Note that the n == 1 condition appears redundant but is not.</span></span><br><span class="line">  <span class="comment">// It prevents "tail" from being referenced (and its head being evaluated)</span></span><br><span class="line">  <span class="comment">// when obtaining the last element of the result. Such are the challenges</span></span><br><span class="line">  <span class="comment">// of working with a lazy-but-not-really sequence.</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || isEmpty) <span class="type">Stream</span>.empty</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) cons(head, <span class="type">Stream</span>.empty)</span><br><span class="line">  <span class="keyword">else</span> cons(head, tail take n<span class="number">-1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">private</span>[scala] <span class="function"><span class="keyword">def</span> <span class="title">filterImpl</span></span>(p: <span class="type">A</span> =&gt; <span class="type">Boolean</span>, isFlipped: <span class="type">Boolean</span>): <span class="type">Stream</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">  <span class="comment">// optimization: drop leading prefix of elems for which f returns false</span></span><br><span class="line">  <span class="comment">// var rest = this dropWhile (!p(_)) - forget DRY principle - GC can't collect otherwise</span></span><br><span class="line">  <span class="keyword">var</span> rest = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">while</span> (!rest.isEmpty &amp;&amp; p(rest.head) == isFlipped) rest = rest.tail</span><br><span class="line">  <span class="comment">// private utility func to avoid `this` on stack (would be needed for the lazy arg)</span></span><br><span class="line">  <span class="keyword">if</span> (rest.nonEmpty) <span class="type">Stream</span>.filteredTail(rest, p, isFlipped)</span><br><span class="line">  <span class="keyword">else</span> <span class="type">Stream</span>.<span class="type">Empty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>[immutable] <span class="function"><span class="keyword">def</span> <span class="title">filteredTail</span></span>[<span class="type">A</span>](stream: <span class="type">Stream</span>[<span class="type">A</span>], p: <span class="type">A</span> =&gt; <span class="type">Boolean</span>, isFlipped: <span class="type">Boolean</span>) = &#123;</span><br><span class="line">  cons(stream.head, stream.tail.filterImpl(p, isFlipped))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，take和filter的返回仍然是一个Stream/Cons，在创建返回Cons对象时，首先计算得到head的值作为hd参数，然后将计算tail的递归逻辑作为tl参数，而tl的值只有在tail方法被调用过才会进行执行/计算，因此在Stream上调用take和filter方法仍然能保持按需计算的特性。当然，如果连head的计算也想推迟，可以使用lazy val变量来声明Stream对象。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在<a href="http://cuipengfei.me/blog/2014/10/23/scala-stream-application-scenario-and-how-its-implemented/" target="_blank" rel="noopener">另外一篇分析Stream的博文</a>的总结里，将List和Stream作了对比，提到“Stream构造的容器，其中不包含数据，包含的时能够生产数据的算法”，感觉挺有道理，不过根据上面的分析，Stream其实同时包括数据（head和已经被访问过的tail）和产生数据的算法（没被访问过的tail），当所有元素都被访问到之后，Stream其实和List就没什么太大的差别了。</p>
<p>想了想之前学习的spark，其实Stream和spark里的RDD倒是有着类似的设计思路。</p>
<blockquote>
<p><strong>Stream</strong></p>
</blockquote>
<ul>
<li>获取数据：通过toStream将其它容器的数据导入到Strean内，或者利用递归定义的序列生成算法构造新的Stream；</li>
<li>Stream API：使用Stream的API对数据进行操作，返回新的Stream对象，此时不会触发tail对应的数据计算逻辑；</li>
<li>非Stream API：使用非Stream的API获取/访问容器内的数据，此时可能会触发新的数据计算过程。</li>
</ul>
<blockquote>
<p><strong>spark RDD</strong></p>
</blockquote>
<ul>
<li>获取数据：从外部数据空间将数据输入spark作为RDD；</li>
<li>transformation（转换）：在RDD上进行transformation操作，返回新的RDD，此时不会执行计算；</li>
<li>action（执行）：触发Spark作业的运行，真正触发transformation转换算子的计算流程，并得到结果数据。</li>
</ul>
<p>最后，由于延迟计算特性，Stream拥有可以表达无限序列的能力，后面打算和Python的generator作一下对比。</p>

      

      
        
    </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/01/handle-infinity-with-stream-and-generator/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          无穷序列：Stream与generator
        
      </div>
    </a>
  
  
    <a href="/2017/03/27/HttpURLConnection-and-webview/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">HttpURLConnection和webview的协同使用</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'youlingmaninfo'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>
    Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>
  </div>
</section>
</section>
        <aside id="sidebar">
  <nav class="menus">
  	<ul>
  		<li><a href="/"><i class="icon icon-home"></i></a></li>
  		
			<li><a href="/archives"><i class="icon icon-fenlei"></i></a></li>
  		
  		
			<li><a href="/tags"><i class="icon icon-tag"></i></a></li>
  		
  		
  			<li><a href="https://github.com/youlingman" target="_blank"><i class="icon icon-github"></i></a></li>
  		
  	</ul>
  </nav>
  <a id="go-top" href="#"><i class="icon icon-up"></i></a>
</aside>
      </div>
      <footer id="footer">
  
	<div id="footer-info" class="inner">
	  &copy; 2020 youlingman 
	  - Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	  - Theme <a href="https://github.com/Alex-fun/hexo-theme-jane/" target="_blank">Jane</a>
	</div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/tags" class="mobile-nav-link">Tag</a>
  
    <a href="https://github.com/youlingman" class="mobile-nav-link">Github</a>
  
</nav>
    
<script>
  var disqus_shortname = 'youlingmaninfo';
  
  var disqus_url = 'http://icyl.rocks/2017/07/01/stream_in_scala/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>