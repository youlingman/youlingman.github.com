<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cyl&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://icyl.rocks/"/>
  <updated>2020-05-13T14:44:06.646Z</updated>
  <id>http://icyl.rocks/</id>
  
  <author>
    <name>youlingman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>skiplist</title>
    <link href="http://icyl.rocks/2020/05/05/skiplist/"/>
    <id>http://icyl.rocks/2020/05/05/skiplist/</id>
    <published>2020-05-05T14:04:12.000Z</published>
    <updated>2020-05-13T14:44:06.646Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习《Redis设计与实现》中提到有序集合底层是基于一种叫skip list的数据结构（以及hash table）来实现，JDK中TreeMap的并发包对应实现ConcurrentSkipListMap也用到了这种数据结构。查了下这个数据结构是1989年才发明出来的，在大学时的课本中以及算法导论里貌似从来没出现过，在这里整理一下学习思路。&lt;br&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://icyl.rocks/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>tomcat如何处理请求：connector篇</title>
    <link href="http://icyl.rocks/2020/04/11/tomcat-connector/"/>
    <id>http://icyl.rocks/2020/04/11/tomcat-connector/</id>
    <published>2020-04-11T12:58:01.000Z</published>
    <updated>2020-05-13T14:44:06.646Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;tomcat是一个Java实现的开源Web应用服务器，目前也是SpringBoot框架的默认内嵌引擎。最近用SpringBoot工程追了下内嵌tomcat的源码，记录一下“tomcat如何处理一次HTTP请求”的过程。以下内容基于SpringBoot内嵌tomcat 9.0.26版本。&lt;br&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://icyl.rocks/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>OAuth与OpenID</title>
    <link href="http://icyl.rocks/2020/03/12/oauth-and-openid/"/>
    <id>http://icyl.rocks/2020/03/12/oauth-and-openid/</id>
    <published>2020-03-12T14:12:31.000Z</published>
    <updated>2020-05-13T14:44:06.646Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近经常遇到客户端和第三方H5之间身份互认的场景，打算在这里总结一下OAuth和OpenID这两个“以为自己了解其实自己并不了解”的知识点。&lt;br&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://icyl.rocks/tags/web/"/>
    
      <category term="security" scheme="http://icyl.rocks/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>容器学习系列-初识docker</title>
    <link href="http://icyl.rocks/2020/03/01/learn-some-container-docker/"/>
    <id>http://icyl.rocks/2020/03/01/learn-some-container-docker/</id>
    <published>2020-03-01T11:19:39.000Z</published>
    <updated>2020-05-13T14:44:06.646Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;对容器和devops感兴趣已久，但是之前犯懒加上工作上没机会接触，一直没认真去了解，最近乘着长假，就着&lt;a href=&quot;https://book.douban.com/subject/30486354/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《深入浅出Docker》&lt;/a&gt;和&lt;a href=&quot;https://www.runoob.com/docker/docker-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程&lt;/a&gt;开始入门Docker，也在自己破电脑上耍了下单机版，记录一下学习小结。&lt;br&gt;
    
    </summary>
    
    
      <category term="container" scheme="http://icyl.rocks/tags/container/"/>
    
      <category term="docker" scheme="http://icyl.rocks/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>2019小结</title>
    <link href="http://icyl.rocks/2020/01/01/HelloCYL-2019_2020/"/>
    <id>http://icyl.rocks/2020/01/01/HelloCYL-2019_2020/</id>
    <published>2020-01-01T15:59:59.000Z</published>
    <updated>2020-05-13T14:44:06.646Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;新的一年，不知不觉已经过了而立之年，最近持续被贩卖蕉绿，中年危机感严重，回来这里给自己做个总结，也给自己订一下目标。&lt;br&gt;
    
    </summary>
    
    
      <category term="cyl" scheme="http://icyl.rocks/tags/cyl/"/>
    
  </entry>
  
  <entry>
    <title>android的handler机制</title>
    <link href="http://icyl.rocks/2018/03/26/android-handler/"/>
    <id>http://icyl.rocks/2018/03/26/android-handler/</id>
    <published>2018-03-26T14:22:22.000Z</published>
    <updated>2020-05-13T14:44:06.646Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在Android应用里，谷歌只允许在主线程即UI线程更新UI，在这个主线程里做一些耗时的操作会导致&lt;a href=&quot;https://developer.android.com/topic/performance/vitals/anr.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ANR&lt;/a&gt;，于是一些耗时间的操作，如网络请求，就需要搬到额外线程去执行，而耗时操作之后往往又需要返回主/UI线程去更新UI。针对这个场景Android提供了一些组件给开发者使用，包括Handler、HandlerThread和AsyncTask，后两者其实都是基于Handler的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://icyl.rocks/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Trampoline和尾递归</title>
    <link href="http://icyl.rocks/2017/11/08/Trampoline/"/>
    <id>http://icyl.rocks/2017/11/08/Trampoline/</id>
    <published>2017-11-08T12:00:35.000Z</published>
    <updated>2020-05-13T14:44:06.646Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/timoxley/functional-javascript-workshop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nodeschool-Functional Javascript&lt;/a&gt;的第13题实现了一个repeat函数，其接收两个参数，函数operation和整数num，然后利用递归对operation调用num次。当num很大时，js会报一个Maximum call stack size exceeded的错误，说明递归太深，调用栈超出限制，第14题的任务就是用一个&lt;strong&gt;trampoline&lt;/strong&gt;函数去解决递归爆栈问题。然而这个trampoline到底是啥exercise里毛说明都木有。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://icyl.rocks/tags/javascript/"/>
    
      <category term="functional" scheme="http://icyl.rocks/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>无穷序列：Stream与generator</title>
    <link href="http://icyl.rocks/2017/08/01/handle-infinity/"/>
    <id>http://icyl.rocks/2017/08/01/handle-infinity/</id>
    <published>2017-08-01T11:57:30.000Z</published>
    <updated>2020-05-13T14:44:06.646Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2017/07/01/stream_in_scala/&quot;&gt;上一篇介绍stream&lt;/a&gt;里提到，scala中的Stream可以利用其延迟计算的特性表达和处理无穷序列，而python中则提供了一种称为generator生成器的机制。下面讨论下stream和generator如何表达无穷序列。&lt;br&gt;
    
    </summary>
    
    
      <category term="functional" scheme="http://icyl.rocks/tags/functional/"/>
    
      <category term="scala" scheme="http://icyl.rocks/tags/scala/"/>
    
      <category term="python" scheme="http://icyl.rocks/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>scala中的Stream</title>
    <link href="http://icyl.rocks/2017/07/01/stream-in-scala/"/>
    <id>http://icyl.rocks/2017/07/01/stream-in-scala/</id>
    <published>2017-07-01T11:57:30.000Z</published>
    <updated>2020-05-13T14:44:06.646Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在之前&lt;a href=&quot;/2017/02/15/lazy_evalutaion_in_scala/&quot;&gt;scala中的延迟求值&lt;/a&gt;中提到，在使用递归遍历的方法解&lt;a href=&quot;https://en.wikipedia.org/wiki/Knight%27s_tour&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;骑士巡游问题&lt;/a&gt;时，可以利用延迟求值的方法来获取需要的部分解（而不用依赖if-else等条件控制流），scala提供了一个lazy list来支持按需计算，称为Stream，这里整理一下相关用法和原理。&lt;br&gt;
    
    </summary>
    
    
      <category term="functional" scheme="http://icyl.rocks/tags/functional/"/>
    
      <category term="scala" scheme="http://icyl.rocks/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>HttpURLConnection和webview的协同使用</title>
    <link href="http://icyl.rocks/2017/03/27/HttpURLConnection-and-webview/"/>
    <id>http://icyl.rocks/2017/03/27/HttpURLConnection-and-webview/</id>
    <published>2017-03-27T06:34:40.000Z</published>
    <updated>2020-05-13T14:44:06.646Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;webview中使用post加载&quot;&gt;&lt;a href=&quot;#webview中使用post加载&quot; class=&quot;headerlink&quot; title=&quot;webview中使用post加载&quot;&gt;&lt;/a&gt;webview中使用post加载&lt;/h3&gt;&lt;p&gt;在项目中遇到一个需求，需要在android的webview中对特定请求（其实就是第一次打开webview的时候）进行可自定义header的post请求，而原生webview提供的post API是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void postUrl(String url, byte[] postData);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不可以自定义header，反观get API可以自定义header，真让人头大。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void loadUrl (String url, 
            Map&amp;lt;String, String&amp;gt; additionalHttpHeaders)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://icyl.rocks/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>scala中的延迟求值</title>
    <link href="http://icyl.rocks/2017/02/15/lazy-evalutaion-in-scala/"/>
    <id>http://icyl.rocks/2017/02/15/lazy-evalutaion-in-scala/</id>
    <published>2017-02-15T11:57:30.000Z</published>
    <updated>2020-05-13T14:44:06.646Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在做&lt;a href=&quot;http://aperiodic.net/phil/scala/s-99/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scala99&lt;/a&gt;的P91 Knight’s tour时，需要递归搜索整个解题空间找到所有可能的解，如果只想要得到部分解，就要先算出全量解再作筛选，这样就要作多余的运算了。在其他编程语言一般利用控制流来实现，即利用if-else条件判断和return返回提前终止搜索过程，而在scala里更functional的写法是利用延迟求值，这里整理下相关的概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="functional" scheme="http://icyl.rocks/tags/functional/"/>
    
      <category term="scala" scheme="http://icyl.rocks/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>Hello CYL</title>
    <link href="http://icyl.rocks/2017/01/31/HelloCYL/"/>
    <id>http://icyl.rocks/2017/01/31/HelloCYL/</id>
    <published>2017-01-31T15:59:59.000Z</published>
    <updated>2020-05-13T14:44:06.646Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;封闭了大半年，喘过气来从新激活下这个hexo博客，感觉技术上的学习还是需要有一个地方记录下，尤其是工作中用不到的、自己学习的东西，也算是一种督促。&lt;/p&gt;
&lt;p&gt;新的一年，在这里给自己订个目标，希望能在这个博客记录下这几个方面的学习和总结吧：&lt;br&gt;
    
    </summary>
    
    
      <category term="cyl" scheme="http://icyl.rocks/tags/cyl/"/>
    
  </entry>
  
</feed>
