<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cyl&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://youlingman.info/"/>
  <updated>2018-03-26T14:16:09.863Z</updated>
  <id>http://youlingman.info/</id>
  
  <author>
    <name>youlingman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://youlingman.info/2018/03/26/android_handler/"/>
    <id>http://youlingman.info/2018/03/26/android_handler/</id>
    <published>2018-03-26T14:16:09.863Z</published>
    <updated>2018-03-26T14:16:09.863Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在Android应用里，谷歌只允许在主线程即UI线程更新UI，在这个主线程里做一些耗时的操作会导致&lt;a href=&quot;https://developer.android.com/topic/performance/vitals/anr.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ANR&lt;/a&gt;，于是一些耗时间的操作，如网络请求，就需要搬到额外线程去执行，而耗时操作之后往往又需要返回主/UI线程去更新UI。针对这个场景Android提供了一些组件给开发者使用，包括Handler、HandlerThread和AsyncTask，后两者其实都是基于Handler的实现。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Trampoline和尾递归</title>
    <link href="http://youlingman.info/2017/11/08/Trampoline/"/>
    <id>http://youlingman.info/2017/11/08/Trampoline/</id>
    <published>2017-11-08T12:00:35.000Z</published>
    <updated>2018-03-26T14:16:09.863Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/timoxley/functional-javascript-workshop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nodeschool-Functional Javascript&lt;/a&gt;的第13题实现了一个repeat函数，其接收两个参数，函数operation和整数num，然后利用递归对operation调用num次。当num很大时，js会报一个Maximum call stack size exceeded的错误，说明递归太深，调用栈超出限制，第14题的任务就是用一个&lt;strong&gt;trampoline&lt;/strong&gt;函数去解决递归爆栈问题。然而这个trampoline到底是啥exercise里毛说明都木有。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://youlingman.info/tags/javascript/"/>
    
      <category term="functional" scheme="http://youlingman.info/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>scala中的Stream</title>
    <link href="http://youlingman.info/2017/07/01/stream_in_scala/"/>
    <id>http://youlingman.info/2017/07/01/stream_in_scala/</id>
    <published>2017-07-01T11:57:30.000Z</published>
    <updated>2018-03-26T14:16:09.863Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在之前&lt;a href=&quot;http://youlingman.info/2017/02/15/lazy_evalutaion_in_scala/&quot;&gt;scala中的延迟求值&lt;/a&gt;中提到，在使用递归遍历的方法解&lt;a href=&quot;https://en.wikipedia.org/wiki/Knight%27s_tour&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;骑士巡游问题&lt;/a&gt;时，可以利用延迟求值的方法来获取需要的部分解（而不用依赖if-else等条件控制流），scala提供了一个lazy list来支持按需计算，称为Stream，这里整理一下相关用法和原理。&lt;br&gt;
    
    </summary>
    
    
      <category term="scala" scheme="http://youlingman.info/tags/scala/"/>
    
      <category term="functional" scheme="http://youlingman.info/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>HttpURLConnection和webview的协同使用</title>
    <link href="http://youlingman.info/2017/03/27/HttpURLConnection-and-webview/"/>
    <id>http://youlingman.info/2017/03/27/HttpURLConnection-and-webview/</id>
    <published>2017-03-27T06:34:40.000Z</published>
    <updated>2018-03-26T14:16:09.863Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;webview中使用post加载&quot;&gt;&lt;a href=&quot;#webview中使用post加载&quot; class=&quot;headerlink&quot; title=&quot;webview中使用post加载&quot;&gt;&lt;/a&gt;webview中使用post加载&lt;/h3&gt;&lt;p&gt;在项目中遇到一个需求，需要在android的webview中对特定请求（其实就是第一次打开webview的时候）进行可自定义header的post请求，而原生webview提供的post API是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void postUrl(String url, byte[] postData);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不可以自定义header，反观get API可以自定义header，真让人头大。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void loadUrl (String url, 
            Map&amp;lt;String, String&amp;gt; additionalHttpHeaders)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://youlingman.info/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>scala中的延迟求值</title>
    <link href="http://youlingman.info/2017/02/15/lazy_evalutaion_in_scala/"/>
    <id>http://youlingman.info/2017/02/15/lazy_evalutaion_in_scala/</id>
    <published>2017-02-15T11:57:30.000Z</published>
    <updated>2018-03-26T14:16:09.863Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在做&lt;a href=&quot;http://aperiodic.net/phil/scala/s-99/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scala99&lt;/a&gt;的P91 Knight’s tour时，需要递归搜索整个解题空间找到所有可能的解，如果只想要得到部分解，就要先算出全量解再作筛选，这样就要作多余的运算了。在其他编程语言一般利用控制流来实现，即利用if-else条件判断和return返回提前终止搜索过程，而在scala里更functional的写法是利用延迟求值，这里整理下相关的概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="scala" scheme="http://youlingman.info/tags/scala/"/>
    
      <category term="functional" scheme="http://youlingman.info/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>Hello CYL</title>
    <link href="http://youlingman.info/2017/01/31/Hello_CYL/"/>
    <id>http://youlingman.info/2017/01/31/Hello_CYL/</id>
    <published>2017-01-31T15:59:59.000Z</published>
    <updated>2018-03-26T14:16:09.863Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;封闭了大半年，喘过气来从新激活下这个hexo博客，感觉技术上的学习还是需要有一个地方记录下，尤其是工作中用不到的、自己学习的东西，也算是一种督促。&lt;/p&gt;
&lt;p&gt;新的一年，在这里给自己订个目标，希望能在这个博客记录下这几个方面的学习和总结吧：&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://youlingman.info/tags/hexo/"/>
    
  </entry>
  
</feed>
