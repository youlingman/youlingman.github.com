<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cyl&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://icyl.rocks/"/>
  <updated>2019-08-26T13:47:54.261Z</updated>
  <id>http://icyl.rocks/</id>
  
  <author>
    <name>youlingman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>android的handler机制</title>
    <link href="http://icyl.rocks/2018/03/26/android_handler/"/>
    <id>http://icyl.rocks/2018/03/26/android_handler/</id>
    <published>2018-03-26T14:22:22.000Z</published>
    <updated>2019-08-26T13:47:54.261Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在Android应用里，谷歌只允许在主线程即UI线程更新UI，在这个主线程里做一些耗时的操作会导致&lt;a href=&quot;https://developer.android.com/topic/performance/vitals/anr.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ANR&lt;/a&gt;，于是一些耗时间的操作，如网络请求，就需要搬到额外线程去执行，而耗时操作之后往往又需要返回主/UI线程去更新UI。针对这个场景Android提供了一些组件给开发者使用，包括Handler、HandlerThread和AsyncTask，后两者其实都是基于Handler的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://icyl.rocks/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Trampoline和尾递归</title>
    <link href="http://icyl.rocks/2017/11/08/Trampoline/"/>
    <id>http://icyl.rocks/2017/11/08/Trampoline/</id>
    <published>2017-11-08T12:00:35.000Z</published>
    <updated>2019-08-26T13:47:54.261Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/timoxley/functional-javascript-workshop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;nodeschool-Functional Javascript&lt;/a&gt;的第13题实现了一个repeat函数，其接收两个参数，函数operation和整数num，然后利用递归对operation调用num次。当num很大时，js会报一个Maximum call stack size exceeded的错误，说明递归太深，调用栈超出限制，第14题的任务就是用一个&lt;strong&gt;trampoline&lt;/strong&gt;函数去解决递归爆栈问题。然而这个trampoline到底是啥exercise里毛说明都木有。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://icyl.rocks/tags/javascript/"/>
    
      <category term="functional" scheme="http://icyl.rocks/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>无穷序列：Stream与generator</title>
    <link href="http://icyl.rocks/2017/08/01/handle-infinity-with-stream-and-generator/"/>
    <id>http://icyl.rocks/2017/08/01/handle-infinity-with-stream-and-generator/</id>
    <published>2017-08-01T11:57:30.000Z</published>
    <updated>2019-08-26T13:47:54.261Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2017/07/01/stream_in_scala/&quot;&gt;上一篇介绍stream&lt;/a&gt;里提到，scala中的Stream可以利用其延迟计算的特性表达和处理无穷序列，而python中则提供了一种称为generator生成器的机制。下面讨论下stream和generator如何表达无穷序列。&lt;/p&gt;
&lt;h3 id=&quot;无穷序列的生成-处理&quot;&gt;&lt;a href=&quot;#无穷序列的生成-处理&quot; class=&quot;headerlink&quot; title=&quot;无穷序列的生成/处理&quot;&gt;&lt;/a&gt;无穷序列的生成/处理&lt;/h3&gt;&lt;p&gt;如何生成一个无穷序列，可以有以下几种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重复某（几）个元素生成序列；&lt;/li&gt;
&lt;li&gt;通过随机生成每个元素生成序列；&lt;/li&gt;
&lt;li&gt;通过特定的递推算法生成序列；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而重复和随机元素都可以归为一种特定的递归算法，下面就以递推生成序列为例。&lt;/p&gt;
&lt;p&gt;当然，任何程序都无法对无穷进行整体操作，一般对无穷序列的处理，主要是对无穷序列进行相应的筛选/截取，以得到想要的有穷数据/信息。比如 &lt;a href=&quot;https://en.wikipedia.org/wiki/Fibonacci_number&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fibonacci number&lt;/a&gt; 就是一个无穷大的序列，对这个序列整体进行处理是不可用的，比如统计序列长度、计算均值等等，我们一般会进行的操作是获取前十个数、获取在[100,200]区间内的fibonacci数等等。&lt;/p&gt;
&lt;p&gt;生成一个fibonacci序列可以通过一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Corecursion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;递推&lt;/a&gt;（这个wiki挺有意思）算法来完成，下面是获取第n个fibonacci数的递推算法。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(n)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; n==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; n==&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fib(n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)+fib(n&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而获取前五个fibonacci数最直接的算法，就是直接通过递推算法逐个获取对应的fibonacci数（废话）。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;fibs = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;  fibs.append(fib(i))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;fibs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="scala" scheme="http://icyl.rocks/tags/scala/"/>
    
      <category term="python" scheme="http://icyl.rocks/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>scala中的Stream</title>
    <link href="http://icyl.rocks/2017/07/01/stream_in_scala/"/>
    <id>http://icyl.rocks/2017/07/01/stream_in_scala/</id>
    <published>2017-07-01T11:57:30.000Z</published>
    <updated>2019-08-26T13:47:54.261Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在之前&lt;a href=&quot;/2017/02/15/lazy_evalutaion_in_scala/&quot;&gt;scala中的延迟求值&lt;/a&gt;中提到，在使用递归遍历的方法解&lt;a href=&quot;https://en.wikipedia.org/wiki/Knight%27s_tour&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;骑士巡游问题&lt;/a&gt;时，可以利用延迟求值的方法来获取需要的部分解（而不用依赖if-else等条件控制流），scala提供了一个lazy list来支持按需计算，称为Stream，这里整理一下相关用法和原理。&lt;br&gt;
    
    </summary>
    
    
      <category term="scala" scheme="http://icyl.rocks/tags/scala/"/>
    
      <category term="functional" scheme="http://icyl.rocks/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>HttpURLConnection和webview的协同使用</title>
    <link href="http://icyl.rocks/2017/03/27/HttpURLConnection-and-webview/"/>
    <id>http://icyl.rocks/2017/03/27/HttpURLConnection-and-webview/</id>
    <published>2017-03-27T06:34:40.000Z</published>
    <updated>2019-08-26T13:47:54.261Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;webview中使用post加载&quot;&gt;&lt;a href=&quot;#webview中使用post加载&quot; class=&quot;headerlink&quot; title=&quot;webview中使用post加载&quot;&gt;&lt;/a&gt;webview中使用post加载&lt;/h3&gt;&lt;p&gt;在项目中遇到一个需求，需要在android的webview中对特定请求（其实就是第一次打开webview的时候）进行可自定义header的post请求，而原生webview提供的post API是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void postUrl(String url, byte[] postData);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不可以自定义header，反观get API可以自定义header，真让人头大。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void loadUrl (String url, 
            Map&amp;lt;String, String&amp;gt; additionalHttpHeaders)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://icyl.rocks/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>scala中的延迟求值</title>
    <link href="http://icyl.rocks/2017/02/15/lazy_evalutaion_in_scala/"/>
    <id>http://icyl.rocks/2017/02/15/lazy_evalutaion_in_scala/</id>
    <published>2017-02-15T11:57:30.000Z</published>
    <updated>2019-08-26T13:47:54.261Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在做&lt;a href=&quot;http://aperiodic.net/phil/scala/s-99/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scala99&lt;/a&gt;的P91 Knight’s tour时，需要递归搜索整个解题空间找到所有可能的解，如果只想要得到部分解，就要先算出全量解再作筛选，这样就要作多余的运算了。在其他编程语言一般利用控制流来实现，即利用if-else条件判断和return返回提前终止搜索过程，而在scala里更functional的写法是利用延迟求值，这里整理下相关的概念。&lt;br&gt;
    
    </summary>
    
    
      <category term="scala" scheme="http://icyl.rocks/tags/scala/"/>
    
      <category term="functional" scheme="http://icyl.rocks/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>Hello CYL</title>
    <link href="http://icyl.rocks/2017/01/31/Hello_CYL/"/>
    <id>http://icyl.rocks/2017/01/31/Hello_CYL/</id>
    <published>2017-01-31T15:59:59.000Z</published>
    <updated>2019-08-26T13:47:54.261Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;封闭了大半年，喘过气来从新激活下这个hexo博客，感觉技术上的学习还是需要有一个地方记录下，尤其是工作中用不到的、自己学习的东西，也算是一种督促。&lt;/p&gt;
&lt;p&gt;新的一年，在这里给自己订个目标，希望能在这个博客记录下这几个方面的学习和总结吧：&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://icyl.rocks/tags/hexo/"/>
    
  </entry>
  
</feed>
