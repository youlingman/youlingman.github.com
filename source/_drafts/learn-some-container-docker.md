---
title: docker学习手札
tags: [container,docker]
---

对容器和devops感兴趣已久，但是之前犯懒加上工作上没机会接触，一直没认真去了解，最近乘着长假，就着[《深入浅出Docker》](https://book.douban.com/subject/30486354/)和[菜鸟教程](https://www.runoob.com/docker/docker-tutorial.html)开始入门Docker，也在自己破电脑上耍了下单机版，记录一下学习小结。

<!--more-->

### 回顾：ops与IaaS

首先回顾一下之前经历过的服务器管理和openstack学习。

以前在实验室管刀片服务器的时候，需要先在服务器裸机上装vmware，然后通过vmware来加载镜像（操作系统镜像），再新增和管理实例，本质上是通过hypervisor层来管理物理服务器资源，向上提供节点实例（类比实际的物理机器节点），打比方把服务器的计算资源比作一个大蛋糕，hypervisor层负责切分出并管理一个个小蛋糕。

这种模式最典型的例子是VPS零售商，向用户交付虚拟主机裸机。从ops的角度，不方便的地方一个是基于单一物理服务器，扩展和迁移不太灵活，一个是管理上没有什么现成运维管理工具需要额外定制开发，还有就是虚拟机镜像的更新和维护也十分笨重。而从dev角度来看，用户（也就是开发人员）需要额外去搞定开发/运行相关配置，如装依赖、下代码、跑通环境等等。

后来调研鼓捣了下openstack（folsom/grizly版本），openstack是在hypervisor之上的IaaS管理平台，与普通hypervisor的主要不同在于：

1. 提供一站式的IaaS服务；
2. 显式划分出计算、网络、存储几种核心资源的管理组件，hypervisor归入计算组件下管理；
3. 面向现有服务器集群部署，根据节点部署的对应openstack服务，划分为管理节点、计算节点、网络节点、存储节点，同一个节点可以身兼数职；

这种模式典型的是AWS、阿里云等云服务商，提供比较全面的基础设施资源管理能力，但是笨重的镜像问题仍然存在，而且如果是基于现有集群再启新VM的方式，性能花销不小。开发人员拿到VM实例后也还是要去重复的调开发/运行环境。

### docker初览

随着容器技术的发展，docker横空出世。docker提供一种轻量级VM-容器的概念，可以实现快速灵活的实例生成和部署维护，其优点主要基于以下两点：

**内核共享的隔离技术**

docker容器和普通VM最大的不同，在于容器实例是利用共享内核的隔离技术创建出来的，而普通VM实例则是基于（硬件）虚拟化技术创建出来的。（硬件）虚拟化创建出来的VM实例本质上是在物理设备上运行的一个个独立的OS，而通过docker创建出来的容器实例，则可以理解为通过进程空间隔离、资源限制、目录结构隔离创建出沙盒环境，然后在该沙盒内挂载对应镜像的文件系统，从而提供一个类虚拟机的运行实例。通过共享宿主OS内核，容器的运行开销相对于虚拟化VM来说有所降低，因此容器实例可以提供进程级别的启动速度和性能。

**多层结构镜像与标准化构建**

容器镜像本质上是对运行环境文件系统的打包，docker的镜像为分层结构，类比面向对象的父类继承结构，一个docker镜像可能由多层组成，不同镜像间可能会共享某些镜像层，基于分层结构，镜像的更新可以实现增量更新，每次更新只需要下载差异的部分，这可以大大加快镜像分发部署和容器迁移。

同时通过Dockerfile，docker可以提供统一的镜像封装机制，以往ops积累的shell脚本、perl脚本、python脚本，都可以统一纳入Dockerfile来管理维护，Dockerfile本身作为部署计划的脚本化成果可以纳入版本管理，而对应构建出来的容器镜像则作为部署动作的发起点。这个和Google SRE的运维工程化以及DevOps理念是一致的。

利用容器镜像来交付应用，docker可以为迁移和部署（尤其是跨环境情况）的一致性提供保证，加上容器本身的隔离性，这个可以大大减轻开发和部署人员的心理压力。

### 容器的使用

既然容器这么好用，作为一个开发人员，应该如何使用容器呢？

从开发规模来看，如果是个人/小团队的原型开发情况，感觉docker很适合作为部署工具来快速部署验证应用，同时也可以为实际部署积累工程化成果；

而如果是大型项目开发，则要考虑系统本身（或部分组件）是否合适容器化。对于应用开发者而言，容器实例其实更接近于一个进程和其对应运行环境（文件系统）的快照，将容器实例类比为一个JVM进程可能对于开发工程师来说更好理解。

