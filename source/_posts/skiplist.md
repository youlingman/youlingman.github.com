---
title: skiplist
tags: algorithm
date: 2020-05-05 22:04:12
---


最近在学习《Redis设计与实现》中提到有序集合底层是基于一种叫skip list的数据结构（以及hash table）来实现，JDK中TreeMap的并发包对应实现ConcurrentSkipListMap也用到了这种数据结构。查了下这个数据结构是1989年才发明出来的，在大学时的课本中以及算法导论里貌似从来没出现过，在这里整理一下学习思路。
<!--more-->

## 有序线性表

首先，skip list是一种用来存放维护有序数据的线性表。一般常用的线性表有数组和链表，数组能提供O(1)复杂度的随机访问和O(n)复杂度的插入/删除操作，而链表则能提供O(n)复杂度的随机访问和O(1)复杂度的插入/删除操作。

对于有序线性表，为了保持数据的有序性，在进行插入/删除操作前首先需要通过查找操作定位到对应增删的位置。如果利用数组来维护有序数据集合，具有O(logn)的查询复杂度和O(n)的新增/删除复杂度，而如果利用链表来维护有序数据，则具有O(n)的查询复杂度和O(n)的新增/删除复杂度。可见线性表虽然实现简单，但是新增/删除复杂度并不令人满意。

## 平衡树

平衡树是用于存储维护有序数据集的树形数据结构，红黑树是工业上常用的二叉平衡树的实现，相对于有序线性表来说，红黑树可以对有序数据集稳定提供O(logn)时间复杂度的查找和增删操作，但是红黑树存在理解困难和实现复杂的问题，要实现一个没有bug的红黑树并不是一项简单的任务。当年看《算法导论》也是被红黑树的各种左旋右旋劝退过。

## skip list

有没有可能在线性表的基础上突破O(n)复杂度呢？由于数组连续存储的特性，其增删操作没有什么优化空间，而对于链表来说，随机访问的性能可以通过空间换时间的思路优化，具体来说就是通过引入额外指针(类似索引)的方式加快随机访问特定节点的性能。

下面以一个对长度为9的有序链表进行二分查找的过程为例。

1. 按二分查找算法，首先需要访问4节点与key对比，链表来说需要从表头跳4步才能访问到4节点，因此这里可以新建一个0->4的指针加快访问，同时新建4->8的指针加快对8节点的访问；
2. 假设key与4节点不匹配，key可能在[0, 4)或者(4, 8]区间，按照二分查找算法需要访问2/6节点，因此这里新建0->2，2->4，4->6，6->8的指针以加快访问；

通过新增额外索引指针，对链表节点的随机访问可以实现跨区间的skip access以提升访问速度，skip list就是通过这个的思路在链表基础上实现O(logn)时间复杂度的查找和增删操作。但是和平衡树不同，skip list提供的是不严格稳定的“概率平衡”。

### 结构

skip list结构上是一个多层的有序链表，每個节点维护额外的指针指向链表中其它节点，有k个指针的节点称为level-k层节点，假设链表中节点最大level值为maxLevel，则该skip list实际维护了maxLevel层链表。

比如上一节的例子里的有序链表，实际上在原链表上额外维护了两层skip链表，由高往低分别为：

* 0---------->4---------->8->null level3层skip链
* 0---->2---->4---->6---->8->null level2层skip链
* 0->1->2->3->4->5->6->7->8->null level1层skip链（原始链表）

这里每层skip链的意义是将有序数据划分成的多个连续有序range区间，遍历对应skip链可以确定目标key在哪个range区间中。由于更高层skip链具有更大的range区间大小，通过由高往下逐层遍历链表，可以逐步缩小目标key的确定所在区间，直到确定查找成功或者失败为止。

对skip list的查询是简单的贪心算法策略，首先从头节点的最高层链表开始向右遍历查询，当无法往右时，即遇到比key大的节点时，跳到下一层链表，然后继续之前的步骤，不断往右遍历、往下跳一层。

其实在有序数组和红黑树中的查找操作中，本质上也是通过对原数据区间进行划分，进而不断缩小确定目标所在的区间，不同在于有序数组是在查找过程中基于下标random access动态划分二分区间，而红黑树则是在每次增删时通过额外平衡旋转操作将二分区间划分信息维护在树形数据结构中。

### 概率平衡

有序数据结构的关键在于在动态增删操作中如何维护平衡性，即查找和增删操作复杂度不会退化到O(n)。

对于skip list，增删节点的操作十分简单。

* 新增节点：首先通过查找确认插入key的节点位置，然后新建节点，同时**随机确定**该新建节点的level层，最后将该节点插入到1至level各层的skip链中。
* 删除节点：首先通过查找确认待删除key的节点，然后从上往下对各层skip链删除该节点。

skip list算法的精髓在于，新增节点的level层是随机确定的，根据生成算法，越低的level值概率越大，同时由于随机生成的level存在无限増长的可能，这里引入了最大层数限制，取值为MaxLevel=log 1/p N，N为链表容量上限。

```
randomLevel()
  lvl := 1
  -- random() that returns a random value in [0...1)
  while random() < p and lvl < MaxLevel do
    lvl := lvl + 1
  return lvl
```

利用随机生成算法可以调整不同层链表节点数的概率分布情况，在原始论文的讨论中取概率p为1/2，则概率上第i层链表的节点数占总节点数量的pow(1/2, i)。正是不同层链表节点数量在概率分布上的特性可以支持O(logn)查询和增删操作。

### 复杂度分析

看了极客时间《数据结构与算法之美》的跳表篇，里面的复杂度是针对一个静态的skip list来分析的，然而按照新增节点算法的随机性，随着不断地新增和删除节点后，skip list的结构很可能发生变化，这个分析思路不大合理。

回头学习下原论文，原论文的思路比较绕。首先，论文提出从节点数的期望值为1/p的链表层开始查找是比较理想的节点数期望值为1/p的层高可以通过L(n)公式计算，其中n为当前链表的节点数。这个L(n)的提出在原论文缺乏上下文的背景说明，这里选择先接受这个设定。

```
L(n) = log 1/p n
```

其实根据randomLevel()算法，第k层链表节点数量的期望值应该是：

```
n, k = 1
n * (1-p) * pow(p, k - 2), k > 1
```

因此第L(n)层的节点数量期望实际为 (1 - p) / pow(p, 2)，如果p取为1/2则与1/p相同。

对于skip list，不管是查询还是新增/删除，都需要先做一次查询操作找到对应节点位置，因此增删操作的复杂度是由查询操作来决定的，这里只分析查询操作的复杂度。

一次查询操作的时间复杂度，可以对应在skip list中对特定值的查询路径长度，其从最高层链表开始遍历，逐步往右/往下遍历直到找到对应节点。这里顺着查询路径目标节点反向看，把反向查询路径分成了两个部分，一部分是“从目标节点反向向上爬k层”部分，而第二部分则是爬到第k层后的剩余查询路径部分。

先看“从目标节点反向向上爬k层”的部分。首先假设每层链表都是无限长，根据新增算法，对于处于第i层的特定节点，如果节点同时也在第i+1层skip链表上（p的概率），则查询路径的上一步一定是从上一层链表访问下来，否则上一步则是从当前层链表的前一个节点过来（1-p的概率）。设C(k)为向上爬k层的遍历路径长度，有如下递推公式。

```
C(0) = 0
C(k) = (1–p) (1 + C(k)) + p (1 + C(k–1))
C(k) = 1/p + C(k–1)
C(k) = k/p
```

由于链表不可能是无限长，这个路径长度其实是一个upper bound。通过这个公式可以得到从第一层爬到第L(n)层的路径长度的上限为 (L(n)-1)/p。

接下来看爬到第L(n)层后剩余的查询路径长度。剩余路径的水平方向长度即为L(N)层以上层的节点数量，根据上面提到过的链表节点数期望公式，L(n)以上层的剩余的节点数量期望值为：

```
(1 - p) / p + (1 - p) + (1 - p) * p + ... = 1 / p
```

最后来到剩余路径的垂直方向的长度部分。首先长度为n的链表最大高度大于k的概率为 1 – pow((1–pow(p,k),n)，这里应该是假设每个节点的随机生成高度都是独立事件而得到的，这个概率最大是n*pow(p,k)，因此可以得到L(N)层以上剩余链表高度的最大期望值为 1/(1–p)。

最后，将“从第一层爬到第L(n)层的路径长度上限”加上“L(n)以上层的剩余节点数量期望”再加上“L(n)层以上剩余层高期望”，就可以得到一次查询路径长度的期望值如下。

```
(L(n)-1)/p + 1 / p + 1/(1–p) = L(n)/p + 1/(1–p) = log(1/p,n)/p + 1/(1–p)
```

因此skip list的查询操作在概率上的“期望”时间复杂度为O(log n)。证毕。

## 小结

skip list是一种为有序数据集提供“概率上”O(logn)复杂度查询/增删操作的数据结构，与红黑树相比由实现简单、支持区间查询、数据有序存放等优点，主要实现有JDK的ConcurrentSkipListMap以及Redis的有序集合。