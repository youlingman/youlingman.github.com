---
title: tomcat如何处理请求：connector篇
tags:
  - web
date: 2020-04-11 20:58:01
---

tomcat是一个Java实现的开源Web应用服务器，目前也是SpringBoot框架的默认内嵌引擎。最近用SpringBoot工程追了下内嵌tomcat的源码，记录一下“tomcat如何处理一次HTTP请求”的过程。以下内容基于SpringBoot内嵌tomcat 9.0.26版本。
<!--more-->

# 概览

一个tomcat服务由（一到多个）连接器Connector和（一个）容器Container组成，其中Connector完成了接受请求建立连接的部分，Container则负责执行处理请求的应用层逻辑。

# 请求处理流程

每个Connector负责在指定的端口上监听请求，建立socket tcp连接，解析请求，初始化Request和Response对象，然后传递给Container的对应servlet，在servlet内完成对请求的处理和返回。

Connector由Endpoint、Processor、Adapter几个核心组件构成，其启动时会启动Endpoint负责监听端口等待连接请求，当客户端请求到达时首先就会从Endpoint开始被处理。

## Endpoint

Endpoint是典型的单进程多线程模型，请求到达tomcat时，由Endpoint完成连接维护和IO读写操作的封装，然后将封装好的SocketWrapper交给Processor进行HTTP协议处理。注意tomcat的连接数和线程数都是在Endpoint这里进行控制的。

Endpoint共有NIO、NIO2和APR三种模式。

### NioEndpoint

NIO模式，对应Java的nio包系列实现。NIO模式包括一个acceptor线程、一个poller线程、一个blockpoller线程和worker线程池。

Connector初始化时启动acceptor轮询线程，利用ServerSocketChannel监听端口并阻塞在accept方法，当有新的请求时唤醒线程建立连接，把新的连接封装成PollerEvent事件添加到poller的事件队列中。注意acceptor建立连接后会将SocketChannel设置为非阻塞，因此后续IO操作需要额外polling。

poller线程为轮询线程，被唤醒后首先处理PollerEvent队列，将连接SocketChannel注册到selector上，然后用selector监听注册连接集上的读写IO事件（非阻塞/超时阻塞），最后将读写就绪的socket封装成SocketProcessor交给worker线程池运行，最后经handler传到对应processor处理。后续processor、adapter、servlet的处理流程都会在这里调度的worker线程内完成。注意这里poller线程取出IO就绪的socket后，**对于非sendfile场景**，会将其对应监听事件interestOps清除，但是仍保留socket在selector上的注册。

后续worker线程对连接的读写由NioSocketWrapper提供封装方法，其中读取操作为从socket中将内容读取到read bytebuffer中供应用逻辑使用，写入则为将待写入内容转移到write bytebuffer中再将write bytebuffer的内容写到socket去。

socketwrapper提供的读写方法有阻塞和非阻塞两种模式。由于连接建立时已经将SocketChannel设置为非阻塞模式，非阻塞的读写直接调用SocketChannel的read/write即可完成，而如何在非阻塞SocketChannel上实现阻塞读写的效果呢？这里NioSocketWrapper维护了两个countdownlatch作为读/写同步器，同时额外跑了一个blockpoller轮询线程监听自有selector（与poller线程的selector不是同一个）上的io事件，当worker线程调用阻塞模式读写方法时，其会将SocketChannel注册到blockpoller线程的selector，然后阻塞在读/写countdownlatch上，blockpoller线程轮询selector监听读写就绪事件，然后通过countdownlatch通知阻塞的worker线程继续执行读/写，从而实现阻塞读写的效果。

NIO模式下存在两个polling线程poller和blockpoller，当前连接socket可能会同时被注册到两个selector上监听其对应IO事件，这个实现比较难以理解，直觉上来说poller线程应该只负责分发读写就绪socket到worker线程池处理，而blockpoller只负责在连接的非阻塞SocketChannel上提供阻塞读写能力，但poller作为单线程却还要负责处理sendfile未完成的transferTo写入操作，这块会不会影响poller的处理性能呢？

### Nio2Endpoint

NIO2模式，对应Java的nio包的异步io系列实现。NIO2模式包括acceptor和worker线程，和NIO模式的不同在于其把acceptor的ServerSocketChannel换成了AsynchronousServerSocketChannel，利用AIO/NIO2的异步机制，连接accept和读写都可以异步进行，acceptor的执行交由线程池统一管理，依赖poller线程selector轮询监听连接读写就绪可以省去，当accept/read/write完成异步通知到CompletionHandler时，直接将读写就绪的socket分发给woker线程池处理，或者进行相关读写事件处理即可。

NIO2模式下的Nio2SocketWrapper基于AsynchronousSocketChannel，提供阻塞和非阻塞两种读写模式，阻塞模式为直接获取读/写结果的Future然后阻塞在Future.get上，非阻塞模式则是利用NIO2的异步读写接口完成读写操作并通知CompletionHandler。

由于FileChannel的transferTo方法不支持AsynchronousSocketChannel，所以NIO2模式的sendfile处理是先将文件filechannel的内容缓存到write buffer，再将write buffer写入到socket去。

### AprEndpoint

APR模式和NIO模式类似，也是acceptor+poller+worker的请求处理模式，不过nio包的ServerSocketChannel和Selector改成了用JNI直接调apache库的实现，以提高性能。同时相对NIO模式来说，APR模式额外多加了一个Sendfile线程专门处理sendfile写入操作，优化了Nio模式中poller被大文件sendfile写入阻塞导致的性能下降。

## Processor

当Endpoint完成底层网络处理后，连接的socket就由独立worker线程交到Processor进行下一步处理。在Processor处理之前，ConnectionHandler会根据连接状态维护当前连接集，每条连接对应一个socket-processor对。

Processor完成的工作是通过socket输入流读取解析HTTP协议和请求头，初始化request和response，然后将request和response传递给adapter进行后续操作。

注意Processor初始化的request和response是tomcat自己定义的coyote包下的类，而不是servlet接口中的ServletRequest和ServletResponse。通过Endpoint和Processor合作，完成了将底层网络连接socket封装成coyote request/response的工作，这对组合被称为tomcat的连接器组件coyote。

## Adaptor

Adapter负责连接Connector和Container，其接收Processor传过来的coyote request/response，解析封装后得到ServletRequest/ServletResponse，根据请求URI匹配得到对应容器，然后将ServletRequest/ServletResponse传入关联容器的Pipeline启动第一个Valve，驱动对应servlet容器处理请求流程。

# 小结

一次HTTP请求在tomcat的Connector处理流程如下：

* 请求首先被监听端口的Endpoint接收，Endpoint将连接socket封装成SocketWrapper交给Processor处理，后续请求处理会运行在关联线程池的独立线程内；
* Processor利用连接socket封装得到本次请求对应的coyote request/response实例对，并传递给Adapter处理，至此Connector完成coyote连接器工作；
* Adapter负责适配连接Connector和Container（coyote和servlet），其将Connector自有的coyote request/response请求实例转换成servlet规范的请求实例ServletRequest/ServletResponse，根据请求匹配出对应容器，然后将ServletRequest/ServletResponse传入对应容器，驱动后续servlet处理。